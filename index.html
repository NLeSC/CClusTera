<html>
<head>   
    <style>


         #frame {
             position: absolute;
             top: 0;
             bottom: 0;
             left: 285;
             right: 0;
             z-index: 0;
         }


         #label {
             position: absolute;
             top: 80;
             left: 15;
             z-index: 1;
             color: black;
             font-family: sans-serif;
         }

         #label2 {
             position: absolute;
             top: 80;
             left: 60;
             z-index: 1;
             color: black;
             font-family: sans-serif;
         }

         #labelcolor {
             position: absolute;
             top: 220;
             left: 15;
             z-index: 1;
             color: black;
             font-family: sans-serif;
         }

          #labelproperty {
             position: absolute;
             top: 155;
             left: 15;
             z-index: 1;
             color: black;
             font-family: sans-serif;
         }

        /*#labelproperty2 {
             position: absolute;
             top: 330;
             left: 15;
             z-index: 1;
             color: black;
             font-family: sans-serif;
         }*/
         #title {
             position: absolute;
             top: 15;
             right: 15;
             z-index: 1;
             color: white;
             font-family: sans-serif;
         }

         #labelnode {
             position: absolute;
             top: 10;
             left: 15;
             z-index: 1;
             color: black;
             font-family: sans-serif;
         }

         /*#sliderObj {
             position: absolute;
             top: 110;
             left: 15;
             z-index: 1;
             font-family: sans-serif;
         }*/


          #colortable {
             position: absolute;
             top: 240;
             left: 15;
             z-index: 1;
             font-family: sans-serif;
         }

         #comboObj {
             position: absolute;
             top: 180;
             left: 15;
             z-index: 1;
             font-family: sans-serif;
         }

          /*#comboObj2 {
             position: absolute;
             top: 350;
             left: 15;
             z-index: 1;
             font-family: sans-serif;
         }*/
    </style>
</head>

<body>

    <input type="text" name="search" id="search" class="textbox" />
    <button style="background-color:white" onclick="searchSequence()" name="button">Search</button>
    <p> </p>
    <button style="background-color:white" onclick="fastLoadAllData()" name="button">Load all data</button>
    <p> </p>
    <input type="checkbox" name="showedges" id="showedges" />

    <label> Show edges</label> 
    
    <div id="frame"></div>
    <!--<div id="graph"></div>-->
    <!--<div id="sliderObj" min="0" max="4" step="1" value="0" vertical="false" size="245"></div>-->
    <!--<div id="label">Level: </div>-->
    <!--<div id="labelnode">Sequence id: </div>-->
    <!--<div id="label2">0</div>-->

    <div id="labelproperty">Colorize by a numerical property:</div>
    <!--<div id="labelproperty2">Colorize by family, type, etc:</div>-->
    <div id="labelcolor">Click inside to select a color:</div>
    <div id="comboObj" width="245"></div>
    <!--<div id="comboObj2" width="245"></div>-->
    <!--<div id="colorpickerObj"></div>-->

    <table cellspacing="2" cellpadding="2" border="0" id="colortable">
        <tr><td><input type="text" id="inputcolor" colorbox="true"></td></tr>
    </table>

    <link rel="stylesheet" type="text/css" href="src/dhtmlx.css">
    <script src="src/dhtmlx.js"></script>
    <script src="dist/graphosaurus.js"></script>
    <script src="src/uifunctions.js"></script>    
    <script src="data/smalldata.js"></script><!--use this if you want to include a js file (with data e.g.) before loading the page. Great for small data sitting on the server-->
    <script src="data/level.js"></script>

    <!--<script src="data/smalldata.js"></script>-->
    <script charset="4">

      //for asynchronously downloading a file from the server. do not change it
        function fetchJSONFile(path, callback) {
            var httpRequest = new XMLHttpRequest();
            httpRequest.onreadystatechange = function () {
                if (httpRequest.readyState === 4) {
                    if (httpRequest.status === 200) {
                        var data = JSON.parse(httpRequest.responseText);
                        if (callback) callback(data);
                    }
                }
            };
            httpRequest.open('GET', path);
            httpRequest.send();
        }
        
        

        document.onkeydown = KeyPress;//see src/uifunctions.js. This function is for handling ctrl+z events
        var edgesShow = document.getElementById("showedges");

        edgesShow.checked = true; //show edges by default

        edgesShow.onchange = function () {
            redrawSameScene();
        }
        
        defineCombo();      
       // defineCombo2();        
        var myColorpicker;
        defineColorPicker2();

        var cursorX;
        var cursorY;
        document.onmousemove = function (e) {//we have to track where the mouse is for the pop-up message

            cursorX = e.clientX;
            cursorY = e.clientY;
        }

        document.onclick = function (e) {
            myPop.hide();
        }
        
        //var mySlider = new dhtmlXSlider("sliderObj");
        //defineSlider();

        var myPop = new dhtmlXPopup();
        //var myPopSlider = new dhtmlXPopup({ slider: mySlider });

        //updateSliderPopupValue(mySlider.getValue())

        var pointsSet;
        var previousNumberOfNodes = []; //is used in ctrl+z, for every click
        var previousNumberOfEdges = []; //is used in ctrl+z, for every click
        var clicked = 0; //is used in ctrl+z
        var lastOpenNode = [];//is used in ctrl+z, for every click
        var nodesColor = "white";

        var CurrentDir = [];//for every nodeID. should be actually a property of the node, move it if you have time.
        var CurrentLevel = [];//also

        var edges = [];//edges is a backup of the current edges in the graph, regardless of whether they are shown or not  . should be a backupEdges property of the graph      
        var labelPositionX = [];//leftover from when I was trying to put labels on the expandable nodes. not used
        var labelPositionY = [];
        //for debugging
        var previoslyhoveredNode;
        var previoscolor;
        //endfordebugging

        var graph = G.graph({
            sizeAttenuation:true,
            nodeImage: "examples/eve-universe/disc.png",
            nodeImageTransparent: true,
            antialias: true,
            bgColor: 'lightgrey',//'lightskyblue',
            edgeWidth: 1,
            nodeSize: 0.016,
            edgeWidth: 0.005,
            hover: function (node) {//what should happen when a user hovers over a node with the mouse                             
                ////for debugging
                if (previoslyhoveredNode != undefined)
                {
                    var stringColor = "#" + previoscolor;                    
                    previoslyhoveredNode.setColorHex(stringColor);
                }
                previoscolor = node.getColor();
                previoslyhoveredNode = node;
                node.setColor("rgb(255,255,255)");
                redrawSameScene();
                ////endfordebugging
                var props = node._propertiesValues;
                var text = node.getId() + "<br>" + props[0] + "<br>" + props[2] +  "<br>" + props[4]
              
                if (node._expandable) { text = "Click me! <br> " + text; }
                myPop.attachHTML(text);
               
                myPop.show(cursorX, cursorY, 2, 3); //params are: x, y, width, height. 3 and 5 are number of pixels relative to the node where the message should appear(you can play with these numbers)
            },
            mousedown: function (node) {//what should happen when a user clicks on a node
                if (node._expandable) {
                    clicked++;
                    lastOpenNode[clicked] = node;

                    previousNumberOfNodes[clicked] = graph.getNodes().length;
                    if (edges.length == 0)
                    { previousNumberOfEdges[clicked] = 0; }
                    else
                    {
                        previousNumberOfEdges[clicked] = edges.length;
                    }
                    AddNextLevelForNode(node.getId());
                   
                }
            }
        });
    
        var renderFrame;


        //this requests the file and executes a callback with the parsed result once
        // it is available. Calling the level zero
        fetchJSONFile("data/data.js", function (data) {
            // do something with your data
            
            AddLevelZero(data.points);
           
            renderFrame = graph.renderIn("frame");
            renderFrame.reDrawMe();
            //alert(data[0]);
        });

               
        function AddLevelZero(data) //data is a list of lists. The latter has 4 numbers: id,  and 3 cooordinates
        {
            for (var i = 0; i < data.length; i++) {
                var point = data[i];
                var pointid = point[0];
                var coords = point.slice(1, 4);
                var red = Math.floor((coords[0] * coords[0] * 1643 % 256) + 1);
                var green = Math.floor((coords[1] * coords[1] * 328 % 256) + 1);
                var blue = Math.floor((coords[2] * coords[2] * 487 % 256) + 1);
                var properties = point.slice(4, point.length);

                var node = G.node(coords, {
                    id: pointid,
                    propertiesValues: properties,
                    //expandable: CheckIfNodeIsExpandable(pointid, "data"),
                });
                node.setColor("rgb(" + red + "," + green + "," + blue + ")");
                node.name = pointid;
                node.addTo(graph);
                CheckIfNodeIsExpandable(pointid, "data");
                
                CurrentDir[pointid] = "data";
                CurrentLevel[pointid] = 0;
            }

        }

       

        function AddNextLevelForNode(nodeId)
        {
            //this requests the file and executes a callback with the parsed result once
            // it is available
            var path = CurrentDir[nodeId] + "/" + nodeId + "/data.js";
            CurrentLevel[nodeId]++;             
            fetchJSONFile(path, function (data) {
                var dir = CurrentDir[nodeId];
                AddPointsFromList(data.points, nodeId, CurrentLevel[nodeId], dir);                               
                redrawSameScene();
                
            });          
        }
      
        function AddLevelForNodeIfNotAdded(nodeId, level)
        {
           // if (CurrentLevel[nodeId] < level) {
                AddNextLevelForNode(nodeId);
           // }
        }

       

        function CheckIfNodeIsExpandable(nodeId, startdir)
        {
            var node = graph._nodeIds[nodeId];
            if (node != undefined) {
                node._expandable = false;
                //var nodeId = node.getId();
                var path = startdir + "/" + nodeId + "/data.js";

                fetchJSONFile(path, function (data) {
                    if (data.points.length > 1) {
                        node._expandable = true;
                        return;
                    }
                    else {
                        CheckIfNodeIsExpandable(nodeId, startdir + "/" + nodeId);
                    }
                });
            }
            
        }

        function AddPointsFromList(data, parentid, level, dir) //data is a list of a list. The latter has 4 numbers: id,  and 3 cooordinates
        {
            var y = parentid;

            var colorPoint = PrepareColor(level, parentid);

            for (var i = 0; i < data.length; i++) {
                PrepareNodeAndAddIt(data, i, colorPoint);
                var pointid = data[i][0]; 
                CurrentDir[pointid] = dir + "/" + parentid;
                CheckIfNodeIsExpandable(pointid, CurrentDir[pointid]);

                AddNewEdge(y, pointid, colorPoint);
            }                                
            
        }

        function PrepareColor(level, parentId)// a unique color per parent and level
        {
            var y = parentId;
            return "rgb(" + 111 * (level + 1) * (y + 1) % 256 + "," + 20 * (level + 1) * (y + 1) % 256 + "," + 50 * (level + 1) * (y + 1) % 256 + ")";
        }

        function PrepareNodeAndAddIt (data, i, colorPoint )
        {
            var point = data[i];
            var pointid = point[0];
            var coords = point.slice(1, 4);
            var nodeproperties = point.slice(4, point.length);

            var node = G.node(coords, {
                id: pointid,
                propertiesValues: nodeproperties,
                color: colorPoint,
            });

            node.addTo(graph);
            
        }
      
        

        
        function fastLoadAllData()
        {
            if (eve == undefined || eve.length == 0 || lev == undefined)
            {
                alert("All data cannot be loaded. Please click on nodes or use the slidebar");
            }
            else {

                fetchJSONFile("data/data.js", function (data) {
                    // do something with your data
                    RemoveAllEdges();
                    RemoveAllNodes();
                    AddLevelZero(data.points);
                    AddUpToLevel(lev.length-1);
                    redrawSameScene();
                });

            }
        }


        function LoadUpToLevel(sliderlevel) {//if you have cashed data in one file on the server, you can add an if-statement here to call that data instead
           
                //I am removing everything first because data was loaded asynchronously (out of order). Synchronous loading degrades user experience. Probably this (async) can be optimized anyway, but I don't have time
                RemoveAllEdges();
                RemoveAllNodes();
                var level = 0;
                var dir = "data";
              
                AddDataFromFiles(dir, level, sliderlevel, "t");
           
            
   
        }

        function AddUpToLevel(sliderlevel) {
            for (var level = 1; level <= sliderlevel; level++) {
                if ( level < lev.length ) {
                    for (var i = 0; i < eve.points.length; i++) {
                        var system = eve.points[i];
                        var systemId = system[0];

                        if (graph._nodeIds[systemId] == undefined) {
                            var x = lev[level];
                            var y = x[systemId];
                            var colorPoint = PrepareColor(level, y);
                            if (y != "f" && y != "t") {
                                PrepareNodeAndAddIt(eve.points, i, colorPoint);
                                if (level > 0) {
                                    AddNewEdge(y, systemId, colorPoint);
                                }
                                var node = graph.getNode(systemId);
                                node._expandable = false;
                            }
                        }
                    }
                }
            }

        }
       
      

        function AddDataFromFiles(dir, level, sliderlevel, parentId)
        {
           
            if (level <= sliderlevel) {
                var path = dir + "/data.js";

                fetchJSONFile(path, function (data) {
                    
                    var listOfFolders = [];
                    if (level == 0) { y = 1; }
                    else { y = parentId; }
                    var colorPoint = PrepareColor(level, y);
                    for (var i = 0; i < data.points.length; i++) {
                        PrepareNodeAndAddIt(data.points, i, colorPoint);
                        var pointId = data.points[i][0];
                        CheckIfNodeIsExpandable(pointId, dir);

                        if (CurrentDir[pointId] == undefined ||  dir.length > CurrentDir[pointId].length) {
                            CurrentDir[pointId] = dir;//regardless of whether the node was already in the graph
                        }
                        if ( CurrentLevel[pointId] == undefined ||  level > CurrentLevel[pointId])
                        {
                            CurrentLevel[pointId] = level; 
                        }
                        listOfFolders.push(dir + "/" + pointId);
                        if (level > 0) {
                            AddNewEdge(parentId, pointId, colorPoint);
                        }
                        
                    }
                    
                    listOfFolders.forEach(function (entry) {
                        var n = entry.lastIndexOf("/");
                        var parent  = entry.substring(n+1, entry.length);
                        AddDataFromFiles(entry, level + 1, sliderlevel, parent);
                       
                    });
                    redrawSameScene();
                });
            }
        }

        function AddNewEdge(parentId, pointId, colorPoint)
        {
            var y = parentId;
            var newedge = G.edge([y, pointId], {
                color: colorPoint,
            });

            newedge.addTo(graph);

            if (edges.length == 0) {
                edges = graph._edges.slice();
            }
            else {
                edges.push(newedge)
            }
        }

        function RemoveAllEdges() {       //not used at the moment 
            edges = [];
        }

        function RemoveAllNodes() {//not used at the moment
            var numberOfNodes = graph.getNodes().length;
            for (var i = 0; i < numberOfNodes; i++) {
                graph.removeLastNode();
            }
        }

        function RemoveLastNodes() {//when the user has asked to close an open node
            var numberOfNodes = graph.getNodes().length;
            for (var i = 0; i < numberOfNodes - previousNumberOfNodes[clicked]; i++) {
                graph.removeLastNode();
            }
        }

        function RemoveLastEdges() {//when the user has asked to close an open node           
            edges.splice(previousNumberOfEdges[clicked], edges.length - previousNumberOfEdges[clicked]);
        }
      
        function RemoveAllEdgesStartingFromIndex(index)//not used
        {
            edges.splice(index, edges.length - index);
        }

        function RemoveAllNodesNodesStartingFromIndex(index)//not used
        {
            var numberOfNodes = graph.getNodes().length;
            for (var i = 0; i < numberOfNodes - index - 1; i++) {
                graph.removeLastNode();
            }
        }

        function HideAllEdges() {//when the checkbox for show edges is unchecked
            var numberOfEdges = graph._edges.length;         
            graph._edges.splice(0, numberOfEdges);
        }

        // when the  checkbox for show edges is checked. edges is a backup of the current edges in the graph, regardless of whether they are shown or not
        function ShowAllEdges() {
            graph._edges = edges.slice();
        }                
       


        var selectedPropertyIndex;
        function Colorize (col, indexOfProperty)//colorizes the nodes that are already loaded in the graph. Means if you color while still loading data, the new data will not be colored
        {
            indexOfProperty += 5;//because the first 5 are names
            var max = graph._nodes[0]._propertiesValues[indexOfProperty];
            var min = max;
            for (var i = 0; i < graph._nodes.length; i++)
            {
                var value = graph._nodes[i]._propertiesValues[indexOfProperty];
                if (value > max) { max = value;}
                if (value < min) { min = value;}
            }

            var range = max - min;

            //find the max intensity for red or blue or green
            var maxColor = col[1][0];
            if (col[1][1] > maxColor) { maxColor = col[1][1]; }
            if (col[1][2] > maxColor) { maxColor = col[1][2]; }

            var redNew = col[1][0];
            var greenNew = col[1][1];
            var blueNew =  col[1][2];

            if (maxColor > 0)
            {
                 var factor = 255 / maxColor;
                 redNew = factor * col[1][0];
                 greenNew = factor * col[1][1];
                 blueNew = factor * col[1][2];
            }

            for (var i = 0; i < graph._nodes.length; i++ )
            {
                var node = graph._nodes[i];
                var value = node._propertiesValues[indexOfProperty];

                var red = col[1][0];
                var green = col[1][1];
                var blue = col[1][2];

                if (range > 0)
                {
                    red = Math.floor(redNew * (value - min) / range);
                    green = Math.floor(greenNew * (value - min) / range);
                    blue = Math.floor(blueNew * (value - min) / range);
                 }
                node.setColor("rgb(" + red + "," + green + "," + blue + ")");               
            }
            redrawSameScene();
        }

        function SearchAndColorizeByName(name)//searches the nodes that are already loaded in the graph. Means if you color while still loading data, the new data will not be colored
        {
            var nodes = graph.getNodes();
            for (var i = 0; i < nodes.length; i++)
            {
                var node = nodes[i];
                var found = false; 
                var properties = node._propertiesValues;
                for (var j=0; j < 5; j++) // the first 5 properties are names 
                {
                    var prop = properties[j].toLowerCase();
                    name = name.toLowerCase(); 
                    if (prop.search(name) > -1) { found = true; }
                }
                if (found) {
                    node.setColor("red");
                }
                else { node.setColor("white");}
            }
            redrawSameScene();
        }

        function redraw() {
            renderFrame.reDrawMe();
        }

        function redrawSameScene() {
            if (edgesShow.checked)
            {
                ShowAllEdges();
            }
            else
            {
                HideAllEdges(); 
            }
            renderFrame.reDrawMeInSameScene();
        }

    </script>
</body>
</html>
