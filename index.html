<html>
<head>
    <style>


         #frame {
             position: absolute;
             top: 0;
             bottom: 0;
             left: 285;
             right: 0;
             z-index: 0;
         }         

           #sliderObj {
             position: absolute;
             top: 200;
             left: 15;
             z-index: 1;
             font-family: sans-serif;
         }

          #labelproperty {
             position: absolute;
             top: 235;
             left: 15;
             z-index: 1;
             color: black;
             font-family: sans-serif;
         }

          #labelcolor {
             position: absolute;
             top: 300;
             left: 15;
             z-index: 1;
             color: black;
             font-family: sans-serif;
         }

        /*#labelproperty2 {
             position: absolute;
             top: 330;
             left: 15;
             z-index: 1;
             color: black;
             font-family: sans-serif;
         }*/
         #title {
             position: absolute;
             top: 15;
             right: 15;
             z-index: 1;
             color: white;
             font-family: sans-serif;
         }

         #comboObj {
             position: absolute;
             top: 260;
             left: 15;
             z-index: 1;
             font-family: sans-serif;
         }

       


          #colortable {
             position: absolute;
             top: 320;
             left: 15;
             z-index: 1;
             font-family: sans-serif;
         }

        

          /*#comboObj2 {
             position: absolute;
             top: 350;
             left: 15;
             z-index: 1;
             font-family: sans-serif;
         }*/
    </style>
</head>

<body>
    <!--UI components-->
    <input type="text" name="search" id="search" class="textbox" />
    <button style="background-color:white; font: 14px Arial" onclick="searchSequence()" name="button" >Search</button>
    <p> </p>
    <button style="background-color:white ; font: 14px Arial" onclick="fastLoadAllData()" name="button">Load all data</button>
    <p> </p>
    <button style="background-color:white ; font: 14px Arial" onclick="ReturnAllColors()" name="button">Resume colors</button>
    <p> </p>
    <button style="background-color:white ; font: 14px Arial" onclick="ShowExpandableNodes()" name="button">Show expandable</button>
    <p> </p>
    <input type="checkbox" name="showedges" id="showedges" />
    <label style=" font: 15px Arial"> Show edges</label>
    <div id="frame"></div>
    <div id="sliderObj" min="0" step="1" value="0" vertical="false" size="245"></div>
    <div id="labelproperty" style=" font: 15px Arial">Colorize by a numerical property:</div>
    <!--<div id="labelproperty2">Colorize by family, type, etc:</div>-->
    <div id="labelcolor" style=" font: 15px Arial" >Click inside to select a color:</div>
    <div id="comboObj" width="245"></div>
    <!--<div id="comboObj2" width="245"></div>-->
    <!--<div id="colorpickerObj"></div>-->
   
   
    

    <table cellspacing="2" cellpadding="2" border="0" id="colortable">
        <tr>
            <td><input type="text" id="inputcolor" colorbox="true"></td>
        </tr>
    </table>

    <link rel="stylesheet" type="text/css" href="src/dhtmlx.css">
    <script src="src/dhtmlx.js"></script>
    <script src="dist/graphosaurus.js"></script>
    <script src="src/uifunctions.js"></script>      
    <script src="data/MetaData.js"></script>      
    <script charset="4">
                
        //global variables definitions start here    
        var frameStartsAt = 285;
        var edgesShow = document.getElementById("showedges");            
        var myColorpicker;       
        var cursorX;
        var cursorY;       
        var mySlider;   
        var myPop = new dhtmlXPopup();
        var myPopSlider;
        var pointsSet;
        var previousNumberOfNodes = []; //is used in ctrl+z, for every click
        var previousNumberOfEdges = []; //is used in ctrl+z, for every click
        var clicked = 0; //is used in ctrl+z
        var lastOpenNode = [];//is used in ctrl+z, for every click
        var nodesColor = "yellow";
        var CurrentDir = [];//for every nodeID. should be actually a property of the node, move it if you have time.
        var CurrentLevel = [];//also
        var edges = [];//edges is a backup of the current edges in the graph, regardless of whether they are shown or not  . should be a backupEdges property of the graph
        var previoslyhoveredNode;//hovering changes temporarily the color of a node to white, therefore we need to remember this
        var previosHoveredcolor;//the color of previoslyhoveredNode
        var smallData;
        var graph = InitializeGraph(); 
        var renderFrame;
        var totalNumberOfLevels;
        var selectedPropertyIndex;
        var previousColor = [];
        //global variables definitions end here 

        //global code starts here
        if ( bigData == false) {
            mySlider = new dhtmlXSlider("sliderObj");
            myPopSlider = new dhtmlXPopup({ slider: mySlider });
            defineSlider();
            updateSliderPopupValue(mySlider.getValue());
        }
        defineCombo();
        // defineCombo2();
        defineColorPicker2();
        document.onmousemove = function (e) {//we have to track where the mouse is for the pop-up message

            cursorX = e.clientX;
            cursorY = e.clientY;
        }
        document.onclick = function (e) {
            myPop.hide();
        }      

        //this requests the file and executes a callback with the parsed result once
        // it is available. Calling the level zero
        fetchJSONFile("data/data.js", function (data) {
            // do something with your data
            totalNumberOfLevels = FindTotalNumberOfLevels(data);
            if (bigData == false) { mySlider.setMax(totalNumberOfLevels - 1); }
            AddLevelZero(data);
            renderFrame = graph.renderIn("frame");
            renderFrame.reDrawMe();

        });

        document.onkeydown = KeyPress;//see src/uifunctions.js. This function is for handling ctrl+z events
        edgesShow.checked = false; //hide edges by default
        edgesShow.onchange = function () {
            redrawSameScene();
        }

        //global code ends here 

        //the functions definitions start here
        
        function InitializeGraph()
        {
            return G.graph({
                sizeAttenuation: true,//whether to change the size of the nodes for a 3D effect or not
                nodeImage: "examples/eve-universe/disc.png",
                nodeImageTransparent: true,
                antialias: true,
                bgColor: 'lightgrey',//'lightskyblue',
                nodeSize: 0.016,//change to 1 if sizeAttenuation = false, otherwise the nodes are too small and not visible
                edgeWidth: 0.005,//change to 1 if sizeAttenuation = false
                hover: function (node) {//what should happen when a user hovers over a node with the mouse
                    HandleNodeHovering(node);
                },
                mousedown: function (node) {//what should happen when a user clicks on a node
                    HandleNodeClicking(node);
                }
            });
        }
       
        function fetchJSONFile(path, callback) { //for asynchronously downloading a file from the server. do not change it
            var httpRequest = new XMLHttpRequest();
            httpRequest.onreadystatechange = function () {
                if (httpRequest.readyState === 4) {
                    if (httpRequest.status === 200) {
                        var data = JSON.parse(httpRequest.responseText);
                        if (callback) callback(data);
                    }
                }
            };
            httpRequest.open('GET', path);
            httpRequest.send();
        }
       
        function HandleNodeHovering(node) {
            if (previoslyhoveredNode != undefined)//if some node was hovered before, return its color
            { previoslyhoveredNode.setColorHex("#" + previosHoveredcolor); }
            previosHoveredcolor = node.getColor();
            previoslyhoveredNode = node;
            node.setColor("white");//make hovered node white
            redrawSameScene();
            var categories = node._categoriesValues;
            var text = node.getId(); //+ "<br>" + props[0] + "<br>" + props[2] + "<br>" + props[4]
            for (var i = 0; i < categories.length; i++) { text += "<br>" + categories[i]; }
            if (node._expandable) { text = "Click me! <br> " + text; }
            myPop.attachHTML(text);
            myPop.show(cursorX, cursorY, 2, 3); //params are: x, y, width, height. 3 and 5 are number of pixels relative to the node where the message should appear(you can play with these numbers)
        }

        function HandleNodeClicking(node) {
            if (node._expandable) {
                clicked++;
                lastOpenNode[clicked] = node;
                previousNumberOfNodes[clicked] = graph.getNodes().length;
                if (edges.length == 0)
                { previousNumberOfEdges[clicked] = 0; }
                else
                { previousNumberOfEdges[clicked] = edges.length; }
                AddNextLevelForNode(node.getId());
            }
        }

        function AddLevelZero(data) //adds all data in 'data', the latter should contain only the zero level
        {
            for (var key in data) {
                AddNodeAtLevelZero(data, key);
                CheckIfNodeIsExpandable(key, "data");
            }
        }

        function PrepareColorZero(coords) {
            var red = Math.floor((coords[0] * coords[0] * 1643 % 256) + 1);
            var green = Math.floor((coords[1] * coords[1] * 328 % 256) + 1);
            var blue = Math.floor((coords[2] * coords[2] * 487 % 256) + 1);
            return "rgb(" + red + "," + green + "," + blue + ")";
        }

        function AddNextLevelForNode(nodeId) {
            //this requests the file and executes a callback with the parsed result once
            // it is available
            var path = CurrentDir[nodeId] + "/" + nodeId + "/data.js";

            fetchJSONFile(path, function (data) {
                var dir = CurrentDir[nodeId];
                AddPointsFromList(data, nodeId, CurrentLevel[nodeId], dir);
                redrawSameScene();
            });
        }

        function CheckIfNodeIsExpandable(nodeId, startdir) {
            var node = graph._nodeIds[nodeId];            
            if (node != undefined) {
                node._expandable = false;
                if (NumberOfLevels(startdir) < totalNumberOfLevels - 1) {                    
                    var file = startdir + "/" + nodeId + "/data.js";
                    fetchJSONFile(file, function (data) {
                        if (Object.keys(data).length > 1) {
                            node._expandable = true;                            
                        }
                        else {
                            CheckIfNodeIsExpandable(nodeId, startdir + "/" + nodeId);
                        }
                    });
                }
            }
        }

        function NumberOfLevels(startdir)
        {
            var r = (startdir.split("/").length - 1)
            return r; 
        }

        function AddPointsFromList(data, parentid, level, dir) {
            var colorPoint = PrepareColor(level + 1, parentid);
            for (var key in data) {
                PrepareNodeAndAddIt(data, key, colorPoint);
                var pointid = key;
                CurrentDir[pointid] = dir + "/" + parentid;
                CurrentLevel[pointid]++;
                
                CheckIfNodeIsExpandable(pointid, CurrentDir[pointid]);
                AddNewEdge(parentid, pointid, colorPoint);
            }
        }

        function PrepareColor(level, parentId)// a unique color per parent and level
        {
            var y = parentId;
            return "rgb(" + 111 * (level + 1) * (y + 1) % 256 + "," + 20 * (level + 1) * (y + 1) % 256 + "," + 50 * (level + 1) * (y + 1) % 256 + ")";
        }

        function PrepareNodeAndAddIt(data, key, colorPoint) {
            var point = data[key];
            var pointid = key;
            var coords = point.Coordinates;
            var nodecategories = point.Categories;
            var nodeProperties = point.Properties;
            var node = G.node(coords, {
                id: pointid,
                categoriesValues: nodecategories,
                propertiesValues: nodeProperties,
                color: colorPoint,
            });
            node.addTo(graph);
            var node = graph.getNode(key);
            node.setColor(colorPoint);
        }

        function fastLoadAllData() {
            if (bigData == true)
            {
                alert("There is too much data, please click on nodes to expand their clusters");
            }
            else
            {
                fastLoadUpToLevel(totalNumberOfLevels - 1);
            }
        }

        function fastLoadUpToLevel(level) {
            if (smallData == undefined) {
                fetchJSONFile("data/smalldata.js", function (data) {
                    smallData = data;
                    FastImportData(smallData, level);
                });
            }
            else {
                FastImportData(smallData, level);
            }
        }

        function FastImportData(data, level) {
            RemoveAllEdges();
            RemoveAllNodes();
            FastAddUpToLevel(level, totalNumberOfLevels, data);
            redrawSameScene();
        }

        function FindTotalNumberOfLevels(data) {
            var levels = 0;
            for (var key in data) {
                var path = data[key].Path;
                levels = path.length + 1;
                return levels;
            }
            return levels;
        }

        function FastAddUpToLevel(sliderlevel, total, data) {
            if (sliderlevel < total) {
                FastLoadLevelZero(data, sliderlevel);                             
                for (var level = 1; level <= sliderlevel; level++) {
                    for (var key in data) {
                        var system = data[key];
                        var path = system.Path;
                        if (level < total - 1) {
                            if (path[level] == key) {
                                FastAddNode(path, level, data, key);
                                var node = graph.getNode(key);
                                if (level == sliderlevel) {                                    
                                    CheckIfNodeIsExpandable(key, CurrentDir[key]);
                                }
                            }
                        }
                        else {
                            FastAddNode(path, level, data, key);
                            var node = graph.getNode(key);
                            node._expandable = false;                      
                        }
                    }
                }
            }            
        }

        function FastAddNode(path, level, data, key)
        {
            var systemId = key;
            var parent = path[level - 1];
            var colorPoint = PrepareColor(level, parent);
            PrepareNodeAndAddIt(data, key, colorPoint);
            if (level > 0 && parent != systemId) {
                AddNewEdge(parent, systemId, colorPoint);
            }
            var node = graph.getNode(systemId);
            if (CurrentDir[systemId] == undefined && CurrentLevel[parent] == level) //if node systemId appears for the first time
                {
                    CurrentDir[systemId] = CurrentDir[parent];
                }
                else { CurrentDir[systemId] = CurrentDir[parent] + "/" + parent; }
            
            CurrentLevel[systemId]++;            
        }

        function FastLoadLevelZero(data, sliderlevel) {
            var level = 0;
            for (var key in data) {
                var point = data[key];
                CurrentLevel[key] = undefined;
                CurrentDir[key] = undefined;
                var path = point.Path;
                if (graph._nodeIds[key] == undefined) {
                    if (path[level] == key) {
                        AddNodeAtLevelZero(data, key);
                        graph.getNode(key)._expandable = false;
                        if (sliderlevel == 0) {
                            CheckIfNodeIsExpandable(key, "data");
                        }
                    }
                }
               
            }
        }

        function AddNodeAtLevelZero(data, key) {
            var point = data[key];
            var coords = point.Coordinates;
            var colorNode = PrepareColorZero(coords);
            PrepareNodeAndAddIt(data, key, colorNode);
            var node = graph.getNode(key);
            
            CurrentDir[key] = "data";
            CurrentLevel[key] = 0;
        }

        function AddNewEdge(parentId, pointId, colorPoint) {
            var y = parentId;
            var newedge = G.edge([y, pointId], {
                color: colorPoint,
            });
            newedge.addTo(graph);
            edges.push(newedge);
        }

        function RemoveAllEdges() {
            edges.splice(0, edges.length);
        }

        function RemoveAllNodes() {
            var numberOfNodes = graph.getNodes().length;
            for (var i = 0; i < numberOfNodes; i++) {
                graph.removeLastNode();
            }
        }

        function RemoveLastNodes() {//when the user has asked to close an open node
            var numberOfNodes = graph.getNodes().length;
            for (var i = 0; i < numberOfNodes - previousNumberOfNodes[clicked]; i++) {
                graph.removeLastNode();
            }
        }

        function RemoveLastEdges() {//when the user has asked to close an open node
            edges.splice(previousNumberOfEdges[clicked], edges.length - previousNumberOfEdges[clicked]);
        }

        function HideAllEdges() {//when the checkbox for show edges is unchecked
            var numberOfEdges = graph._edges.length;
            graph._edges.splice(0, numberOfEdges);
        }
       
        function ShowAllEdges() {// when the  checkbox for show edges is checked. edges is a backup of the current edges in the graph, regardless of whether they are shown or not
            graph._edges = edges.slice();
        }
       
        function Colorize(col, indexOfProperty)//colorizes the nodes that are already loaded in the graph. Means if you color while still loading data, the new data will not be colored
        {
            var max = graph._nodes[0]._propertiesValues[indexOfProperty];
            var min = max;
            for (var i = 0; i < graph._nodes.length; i++) {
                var value = graph._nodes[i]._propertiesValues[indexOfProperty];
                if (value > max) { max = value; }
                if (value < min) { min = value; }
            }

            var range = max - min;

            //find the max intensity for red or blue or green
            var maxColor = col[1][0];
            if (col[1][1] > maxColor) { maxColor = col[1][1]; }
            if (col[1][2] > maxColor) { maxColor = col[1][2]; }

            var redNew = col[1][0];
            var greenNew = col[1][1];

            if (maxColor > 0) {
                var factor = 255 / maxColor;
                redNew = factor * col[1][0];
                greenNew = factor * col[1][1];
                blueNew = factor * col[1][2];
            }
            for (var i = 0; i < graph._nodes.length; i++) {
                var node = graph._nodes[i];
                var value = node._propertiesValues[indexOfProperty];
                var red = col[1][0];
                var green = col[1][1];
                var blue = col[1][2];
                if (range > 0) {
                    red = Math.floor(redNew * (value - min) / range);
                    green = Math.floor(greenNew * (value - min) / range);
                    blue = Math.floor(blueNew * (value - min) / range);
                }
                var color = "rgb(" + red + "," + green + "," + blue + ")";
                ChangeColor(node, color);
            }
            redrawSameScene();
        }

        function SearchAndColorizeByName(name)//searches the nodes that are already loaded in the graph. Means if you color while still loading data, the new data will not be colored
        {

            var nodes = graph.getNodes();
            for (var i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                var found = false;

                if (node.getId() == name) {
                    found = true;
                }
                else {
                    var categories = node._categoriesValues;
                    for (var j = 0; j < categories.length; j++) {
                        var prop = categories[j].toLowerCase();
                        name = name.toLowerCase();
                        if (prop.search(name) > -1) { found = true; }
                    }
                }
                if (found) {
                    //node.setColor("red");
                    ChangeColor(node, "red"); 
                }
                else { ChangeColor(node, "grey"); }
            }
            redrawSameScene();
        }

        function redrawSameScene() {
            if (edgesShow.checked) {
                ShowAllEdges();
            }
            else {
                HideAllEdges();
            }
            renderFrame.reDrawMeInSameScene();
        }

        function ChangeColor(node, color)
        {
            var id = node.getId();
            previousColor[id] = node.getColor();
            node.setColor(color);
        }

        function ReturnPreviousColor(node)
        {
            var id = node.getId();
            var color = previousColor[id];
            if (color != undefined) {                
                node.setColorHex("#" + color);
            }
        }

        function ReturnAllColors()
        {
            var nodes = graph.getNodes();
            for (var i = 0; i < nodes.length; i++) 
            {
                ReturnPreviousColor(nodes[i]);
            }
            redrawSameScene();
        }

        function ShowExpandableNodes()
        {
            var nodes = graph.getNodes();
            for (var i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                if (node._expandable) {
                    ChangeColor(node, "yellow");
                }
                else { ChangeColor(node, "grey") };
            }
            redrawSameScene();           
        }
        //the functions definitions end here
    </script>
</body>
</html>
