<html>
<head>

   
    <style>


         #frame {
             position: absolute;
             top: 0;
             bottom: 0;
             left: 285;
             right: 0;
             z-index: 0;
         }


         #label {
             position: absolute;
             top: 80;
             left: 15;
             z-index: 1;
             color: black;
             font-family: sans-serif;
         }

         #label2 {
             position: absolute;
             top: 80;
             left: 60;
             z-index: 1;
             color: black;
             font-family: sans-serif;
         }

         #labelcolor {
             position: absolute;
             top: 220;
             left: 15;
             z-index: 1;
             color: black;
             font-family: sans-serif;
         }

          #labelproperty {
             position: absolute;
             top: 155;
             left: 15;
             z-index: 1;
             color: black;
             font-family: sans-serif;
         }

        #labelproperty2 {
             position: absolute;
             top: 330;
             left: 15;
             z-index: 1;
             color: black;
             font-family: sans-serif;
         }
         #title {
             position: absolute;
             top: 15;
             right: 15;
             z-index: 1;
             color: white;
             font-family: sans-serif;
         }

         #labelnode {
             position: absolute;
             top: 10;
             left: 15;
             z-index: 1;
             color: black;
             font-family: sans-serif;
         }

         #sliderObj {
             position: absolute;
             top: 110;
             left: 15;
             z-index: 1;
             font-family: sans-serif;
         }


          #colortable {
             position: absolute;
             top: 240;
             left: 15;
             z-index: 1;
             font-family: sans-serif;
         }

         #comboObj {
             position: absolute;
             top: 180;
             left: 15;
             z-index: 1;
             font-family: sans-serif;
         }

          #comboObj2 {
             position: absolute;
             top: 350;
             left: 15;
             z-index: 1;
             font-family: sans-serif;
         }
    </style>
</head>

<body>

    <input type="text" name="search" id="search" class="textbox" />
    <button style="background-color:white" onclick="searchSequence()" name="button">Search</button>
    <p> </p>
    <input type="checkbox" name="showedges" id="showedges" />

    <label> Show edges</label> 
    
    <div id="frame"></div>
    <!--<div id="graph"></div>-->
    <div id="sliderObj" min="0" max="4" step="1" value="0" vertical="false" size="245"></div>
    <div id="label">Level: </div>
    <!--<div id="labelnode">Sequence id: </div>-->
    <div id="label2">0</div>

    <div id="labelproperty">Colorize by a numerical property:</div>
    <div id="labelproperty2">Colorize by family, type, etc:</div>
    <div id="labelcolor">Click inside to select a color:</div>
    <div id="comboObj" width="245"></div>
    <div id="comboObj2" width="245"></div>
    <!--<div id="colorpickerObj"></div>-->

    <table cellspacing="2" cellpadding="2" border="0" id="colortable">
        <tr><td><input type="text" id="inputcolor" colorbox="true"></td></tr>
    </table>

    <link rel="stylesheet" type="text/css" href="src/dhtmlx.css">
    <script src="src/dhtmlx.js"></script>


    <script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
    <script src="dist/graphosaurus.js"></script>
    <script src="src/uifunctions.js"></script>
    <script src="examples/eve-universe/eve-data.js"></script>
    <script src="examples/eve-universe/level.js"></script>
    <script charset="4">


        function fetchJSONFile(path, callback) {
            var httpRequest = new XMLHttpRequest();
            httpRequest.onreadystatechange = function () {
                if (httpRequest.readyState === 4) {
                    if (httpRequest.status === 200) {
                        var data = JSON.parse(httpRequest.responseText);
                        if (callback) callback(data);
                    }
                }
            };
            httpRequest.open('GET', path);
            httpRequest.send();
        }
        
        document.onkeydown = KeyPress;
        var edgesShow = document.getElementById("showedges");

        edgesShow.checked = true; 

        edgesShow.onchange = function () {
            redrawSameScene();
        }
        
        defineCombo();      
        defineCombo2();        
        var myColorpicker;
        defineColorPicker2();

        var cursorX;
        var cursorY;
        document.onmousemove = function (e) {

            cursorX = e.clientX;
            cursorY = e.clientY;
        }

        document.onclick = function (e) {
            myPop.hide();
        }

        var mySlider = new dhtmlXSlider("sliderObj");
        defineSlider();

        var myPop = new dhtmlXPopup();
        var myPopSlider = new dhtmlXPopup({ slider: mySlider });

        updateSliderPopupValue(mySlider.getValue())

        var pointsSet;
        var previousNumberOfNodes = []; //is used in ctrl+z
        var previousNumberOfEdges = [];
        var clicked = 0; //is used in ctrl+z
        var lastOpenNode = [];
        var nodesColor = "white";// "rgb(255,253,224)";

        var CurrentDir = [];
        var CurrentLevel = [];

        var edges;//edges is a backup of the current edges in the graph, regardless of whether they are shown or not        
            
        var graph = G.graph({
            nodeImage: "examples/eve-universe/disc.png",
            nodeImageTransparent: true,
            antialias: true,
            bgColor: 'lightskyblue',
            edgeWidth: 1,
            nodeSize: 10,
            hover: function (node) {             
                //$("#labelnode").text("Sequence id: " + node.getId());             
                myPop.attachHTML("Sequence id: " + node.getId());
                myPop.show(cursorX, cursorY, 3, 5); //params are: x, y, width, height
            },
            mousedown: function (node) {                 
                    clicked++;
                    lastOpenNode[clicked] = node;

                    previousNumberOfNodes[clicked] = graph.getNodes().length;
                    if (edges == undefined)
                    { previousNumberOfEdges[clicked] = 0; }
                    else
                    {
                        previousNumberOfEdges[clicked] = edges.length;
                    }                
                    AddNextLevelForNode(node.getId());
                    //if (graph._nodes.length == previousNumberOfNodes[clicked])
                    //{
                    //    lastOpenNode[clicked] = undefined;
                    //    previousNumberOfNodes[clicked] = undefined;
                    //    previousNumberOfEdges[clicked] = undefined;
                    //    clicked--;
                    //}
            }
        });
    
        var renderFrame; 
        //this requests the file and executes a callback with the parsed result once
        // it is available
        fetchJSONFile("data/data.js", function (data) {
            // do something with your data
            AddLevelZero(data.points);
            renderFrame = graph.renderIn("frame");
            renderFrame.reDrawMe();
            //alert(data[0]);
        });

        var oldgraph;
        

        function AddLevelZero(data) //data is a list of lists. The latter has 4 numbers: id,  and 3 cooordinates
        {
            for (var i = 0; i < data.length; i++) {
                var point = data[i];
                var pointid = point[0];
                var coords = point.slice(1, 4);
                var red = Math.floor((coords[0] * coords[0] * 1643 % 256) + 1);
                var green = Math.floor((coords[1] * coords[1] * 328 % 256) + 1);
                var blue = Math.floor((coords[2] * coords[2] * 487 % 256) + 1);
                var node = G.node(coords, {
                    id: pointid,
                });
                node.setColor("rgb(" + red + "," + green + "," + blue + ")");
                node.name = pointid;
                node.addTo(graph);
                CurrentDir[pointid] = "data";
            }
        }

        function IncrementCurrentLevelForNode(nodeId)
        {
            if (CurrentLevel[nodeId] == undefined)
            {
                CurrentLevel[nodeId] = 0;
            }
            else 
            {
                CurrentLevel[nodeId]++; 
            }
        }

        function AddNextLevelForNode(nodeId)
        {
            //this requests the file and executes a callback with the parsed result once
            // it is available
            var path = CurrentDir[nodeId] + "/" + nodeId + "/data.js";
            IncrementCurrentLevelForNode(nodeId);   
            fetchJSONFile(path, function (data) {
                var dir = CurrentDir[nodeId];
                AddPointsFromList(data.points, nodeId, CurrentLevel[nodeId], dir);               
               
                redrawSameScene();            
            });          
        }

        function LoadUpToLevel(sliderlevel)
        {
            //RemoveAllNodes();
            //RemoveAllEdges();
            //AddLevelZero();
            var currentLevel = 0;
            
            while (currentLevel < sliderlevel )
            {                
                var nodes = graph.getNodes();
                var numberOfNodes = nodes.length;
                for (var i = 0; i < numberOfNodes; i++)
                {
                    var node = nodes[i];
                    var id = node.getId();
                    AddNextLevelForNode(id);
                }
                currentLevel++;
            }
        }


        function AddPointsFromList(data, parentid, level, dir) //data is a list of a list. The latter has 4 numbers: id,  and 3 cooordinates
        {
            var y = parentid;
            for (var i = 0; i < data.length; i++) {
                var point = data[i];
                var pointid = point[0];
                var coords = point.slice(1, 4);
                var node = G.node(coords, {
                    id: pointid,
                    color: "rgb(" + 111 * (level + 1) * (y + 1) % 256 + "," + 20 * (level + 1) * (y + 1) % 256 + "," + 50 * (level + 1) * (y + 1) % 256 + ")",
                });
               
                node.addTo(graph);
                CurrentDir[pointid] = dir + "/" + parentid;                        
                
                var newedge = G.edge([y, pointid], {
                    color: "white",
                });

                newedge.addTo(graph);

                if (edges == undefined)
                {
                    edges = graph._edges.slice();
                }
                else {
                    edges.push(newedge)
                }
            }                                
            
        }

        function AddLevel (level)
        {
        }
    
        function RemoveLastNodes() {
            var numberOfNodes = graph.getNodes().length;
            for (var i = 0; i < numberOfNodes - previousNumberOfNodes[clicked]; i++) {
                graph.removeLastNode();
            }
        }

        function RemoveLastEdges() {//when the user has asked to close an open node           
            edges.splice(previousNumberOfEdges[clicked], edges.length - previousNumberOfEdges[clicked]);
        }
      
        function RemoveAllEdges() {//when the checkbox for show edges is unchecked
            var numberOfEdges = graph._edges.length;         
            graph._edges.splice(0, numberOfEdges);
        }

        // when the  checkbox for show edges is checked. edges is a backup of the current edges in the graph, regardless of whether they are shown or not
        function ReturnAllEdges() {
            graph._edges = edges.slice();
        }                
       
        function redraw() {
            renderFrame.reDrawMe();
        }

        function redrawSameScene() {
            if (edgesShow.checked)
            {
                ReturnAllEdges();
            }
            else
            {
                RemoveAllEdges(); 
            }
            renderFrame.reDrawMeInSameScene();
        }

    </script>
</body>
</html>
